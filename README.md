# Задача
---
- Существует условный сервер, на котором в оперативной памяти хранится длинная таблица (миллионы строк). Строки отсортированы в некотором порядке, принцип сортировки может меняться, каждая строка имеет свой уникальный идентификатор. Таблица живая, постоянно изменяется (несколько сотен/десятков изменений в секунду). В нее добавляются новые строки, обновляются и удаляются существующие.
- Кроме этого, существует условный клиент, задача которого - отображение этой таблицы в реальном времени (все изменения видны сразу). При этом памяти на клиенте недостаточно для выгрузки всей таблицы. Отображение осуществляется за счет того, что пользователю доступно окно высотой в N строк и в нём скроллер, позволяющий передвигаться по списку и сортировать ее по столбцам. При этом пользователь не ограничен в своих действиях - он может скроллироваться в любую часть списка и выбирать любой столбец для сортировки. Например, если на сервере список из миллиона записей и на клиенте скроллер передвинут на середину, то клиент должен отобразить N записей начиная с полумиллионной.
- Задача - придумать способ для хранения таблицы на сервере и протокол взаимодействия клиента и сервера для быстрого и корректного отображения данных клиентами. Важно, чтобы решение не предполагало использование сторонних продуктов (например, СУБД) или фреймворков. Следует использовать базовые контейнеры данных для выбранного для решения задачи языка (например, контейнеры стандартной библиотеки STL в случае реализации на C++ - map, vector, list или их аналоги в других языках).


# Выжимка из задания
---
- Сервер
	- Таблица из строк
	- Количество строк ~ 10^6 (`миллионы строк`)
	- Каждая строка имеет уникальный ID (`каждая строка имеет свой уникальный идентификатор`)
	- Строки могут быть отсортированы по столбцам (`Строки отсортированы ...`)
	- Строки часто модифицируются / добавляются / удаляются (`Таблица живая, постоянно изменяется (несколько сотен/десятков изменений в секунду`)
- Клиент
	- Отображает N строк << общего количества строк (`... пользователю доступно окно высотой в N строк`)
	- Может сортировать строки по столбцам (`... пользователь ... может ... и выбирать любой столбец для сортировки`)
	- Можно скроллить всю таблицу (`... пользователь ... может скроллироваться в любую часть списка ...)
- Не использовать сторонних библиотек / фреймворков - только встроенные средства, STL


# Пути решения

## Cпособ для хранения таблицы на сервере
---
- Требования:
	- Произвольный доступ к заданной строке (по порядку, а не ключу)
	- Последовательный обход - клиент при запросе не знает конкретные идентификаторы строк, ему известен только порядковый номер строки
	- Частая модификация данных - изменение / добавление / удаление

|Структура данных|Доступ к элементу|Добавление / Удаление|Последовательный обход|
|---|---|---|---|
|`std::vector`|$O(1)$|$O(N)$|Да|
|`std::list`|$O(N)$|$O(1)$|Да|
|`std::map`|$O(log(N))$|$O(log(N))$|Да|
|`std::unordered_map`|$O(1)$|$O(1)$|Нет|

С точки зрения возможности быстрого скроллинга наиболее эффективной структурой является `std::vector`, сложность доступа к элементу по индексу - $O(1)$. Недостатком является высокая сложность модификации таблицы - $O(N)$.

С точки зрения модификации таблицы наиболее эффективной структурой является `std::unordered_map` - $O(1)$. Недостатком является отсутствие возможности последовательного обхода строк, что не позволяет реализовать запрос клиента на `N` строк, начиная с заданной.

Компромиссным вариантом является `std::map`. Обеспечивает более низкую, по сравнению с `std::vector`, сложность модификации таблицы - $O(log(N))$. Имеет возможность последовательно обходить элементы (строки) таблицы, что позволяет реализовать запрос клиента на `N` строк, начиная с заданной. В этом случае сложность поиска заданной строки таблицы - $O(N)$. Чтобы снизить этот негативный эффект можно искать строку с конца, если она ближе к нему.

Вывод - способ для хранения таблицы на сервере - `std::map`, где
- ключ - уникальный идентификатор строки - целое число
- значение - набор столбцов


## Протокол взаимодействия клиента и сервера
---
- Требования
	- Быстрая скорость передачи
	- Клиент запрашивает у сервера выборку из таблицы, передавая параметры:
		- Номер начальной строки
		- Количество строк
		- Номер столбца по которому сортировать строки

- Если передавать пользователю выборку из таблицы в виде контейнера STL (например `std::vector`, `std::list`, `std::map`, ...), то это потребует дополнительные накладные расходы на сериализацию / десериализацию передаваемых данных
- С другой стороны, таблица постоянно изменяется. Эти изменения должны отображаться в реальном времени - в этом случае нет необходимости держать на стороне клиента выборку в виде контейнера STL поскольку данные быстро могут стать неактуальными.

- Поскольку клиент только отображает данные, не модифицируя их, целесообразно передавать данные в виде строки для отображения. При необходимости сортировки или скроллинга - клиент заново запрашивает актуальные данные у сервера.

Вывод - протокол взаимодействия клиента и сервера
- Сервер формирует таблицу, сортирует её, конвертирует в строку `std::string` и отправляет набор байтов клиенту
- Клиент получает `std::string` и отображает её. 
	- Для скроллинга или сортировки клиент отправляет заново запрос на сервер


# Реализация
---
- Сервер и клиент расположены в папках `server`, `client` соответственно
- Сервер и клиент компилируются отдельно

## Сервер
---
- Модуль `Database` - содержит таблицу с данными, предоставляет функции
	- Добавить / удалить строку
	- Вернуть выборку из таблицы по заданным строкам
- Модуль `Network` - предоставляет функции работы по сети:
	- Настройка сети
	- Приём / передача данных
	- Завершение соединения
- Модуль `Handler` - предоставляет функцию обработки запросов от клиентов

## Клиент
---
- Модуль `Network` - предоставляет функции работы по сети:
	- Настройка сети
	- Приём / передача данных
	- Завершение соединения
- Модуль `Handler` - предоставляет функцию обработки запросов от клиентов


# Направления развития
---
- Многопоточная обработка запросов клиентов на сервере
- Обработка ошибок 
	- некорректного ввода запроса
	- приёма / передачи данных
- Отображение изменения данных на клиенте в реальном времени
- Графический интерфейс


# Сборка
---
Находясь в папке `server` / `client` выполнить команду `make`
